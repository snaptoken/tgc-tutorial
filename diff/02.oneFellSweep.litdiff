# One Fell Sweep

The first thing we'll do is build a memory allocator function called
`tgc_alloc()`. It simply wraps the standard library's `malloc()`, but also
remembers each block of memory it allocates. All memory allocated by
`tgc_alloc()` will then be freed at the end of the user's program in "one fell
sweep" when they call `tgc_stop()`.

It won't be a very useful garbage collector at this point, but it lays the
foundation for writing a proper mark-and-sweep garbage collector in the rest of
the tutorial.

## The allocator

Our library will consist of two files: `tgc.h` and `tgc.c`. We'll start by
defining `tgc_alloc()` as a wrapper around `malloc()`, and filling out a little
bit of C boilerplate.

~~~

Create `tgc.h` and add a function prototype for `tgc_alloc()`

Like `malloc()`, it takes the number of bytes to allocate and returns a pointer
to the allocated memory.

diff --git a/tgc.h b/tgc.h
new file mode 100644
--- /dev/null
+++ b/tgc.h
@@ -0,0 +1,1 @@
+void *tgc_alloc(size_t size);

~~~

Include `<stdlib.h>` to get the `size_t` type

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -1,1 +1,3 @@
+#include <stdlib.h>
+
|void *tgc_alloc(size_t size);

~~~

Wrap the header file in an [#include guard](https://en.wikipedia.org/wiki/Include_guard)

This is a standard practice in C that prevents users of the library from
getting errors saying "that's already been defined" when they include the
header file multiple times.

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -1,3 +1,8 @@
+#ifndef TGC_H
+#define TGC_H
+
|#include <stdlib.h>
|
|void *tgc_alloc(size_t size);
+
+#endif

~~~

Create `tgc.c` and implement `tgc_alloc()` as a wrapper for `malloc()`

diff --git a/tgc.c b/tgc.c
new file mode 100644
--- /dev/null
+++ b/tgc.c
@@ -0,0 +1,4 @@
+void *tgc_alloc(size_t size) {
+  void *ptr = malloc(size);
+  return ptr;
+}

~~~

Include the header file

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -1,3 +1,5 @@
+#include "tgc.h"
+
|void *tgc_alloc(size_t size) {
|  void *ptr = malloc(size);
|  return ptr;

~~~

Add an "allocator functions" section

`tgc.c` is going to end up growing to several hundred lines of code. To help
find our way around it, we're going to add special comments that divide it into
small sections.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -1,5 +1,7 @@
|#include "tgc.h"
|
+/*** allocator functions ***/
+
|void *tgc_alloc(size_t size) {
|  void *ptr = malloc(size);
|  return ptr;

~~~

## Pointer table

We need to keep track of each piece of memory we allocate, so that we can
garbage collect it (free it) later. The `tgc_ptr_t` struct will store all the
information we need about an allocated pointer. The `tgc_t` struct will store
the global state for our garbage collector, including the array of `tgc_ptr_t`
structs.

~~~

Add the `tgc_ptr_t` struct

For now all we need to store in the struct is the pointer itself.

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -3,6 +3,10 @@
|
|#include <stdlib.h>
|
+typedef struct {
+  void *ptr;
+} tgc_ptr_t;
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~

Add the `tgc_t` struct

`items` is a dynamically growing array. `nitems` is the number of slots in the
array filled with `tgc_ptr_t` values, and `nslots` is the total number of slots
available in the array. When `nitems` is equal to `nslots`, the array is full
and we'll have to grow the array.

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -7,6 +7,11 @@
|  void *ptr;
|} tgc_ptr_t;
|
+typedef struct {
+  tgc_ptr_t *items;
+  size_t nitems, nslots;
+} tgc_t;
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~

Add the function prototype for `tgc_start()`

The user of our library will call this function at the start of their program
to initialize the global state struct.

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -12,6 +12,8 @@
|  size_t nitems, nslots;
|} tgc_t;
|
+void tgc_start(tgc_t *gc);
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~

Implement `tgc_start()`, initializing an empty pointer table

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -1,5 +1,13 @@
|#include "tgc.h"
|
+/*** gc control ***/
+
+void tgc_start(tgc_t *gc) {
+  gc->nitems = 0;
+  gc->nslots = 0;
+  gc->items = NULL;
+}
+
|/*** allocator functions ***/
|
|void *tgc_alloc(size_t size) {

~~~

## Adding pointers to the pointer table

We're going to want to add each pointer we allocate to this array. To be able
to do that, `tgc_alloc()` needs to take the global state struct as an argument.
In fact, every public function of our library will have `tgc_t *gc` as its
first argument.

~~~

Update function prototype for `tgc_alloc()` to take global state

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -14,6 +14,6 @@
|
|void tgc_start(tgc_t *gc);
|
-void *tgc_alloc(size_t size);
+void *tgc_alloc(tgc_t *gc, size_t size);
|
|#endif

~~~

Update function definition for `tgc_alloc()` to take global state

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -10,7 +10,7 @@
|
|/*** allocator functions ***/
|
-void *tgc_alloc(size_t size) {
+void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  return ptr;
|}

~~~

Call non-existent `tgc_add()` function

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -12,5 +12,6 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
+  tgc_add(gc, ptr);
|  return ptr;
|}

~~~

Implement `tgc_add()` by calling two more non-existent functions

`tgc_resize()` will ensure there is enough room in the array to add one more
pointer, and `tgc_add_ptr()` will actually add it to the array.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -10,6 +10,12 @@
|
|/*** allocator functions ***/
|
+static void tgc_add(tgc_t *gc, void *ptr) {
+  gc->nitems++;
+  tgc_resize(gc);
+  tgc_add_ptr(gc, ptr);
+}
+
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  tgc_add(gc, ptr);

~~~

## Growing the array

`tgc_resize()`'s job is to ensure that the pointer table has enough slots to
store `gc->nitems` pointers. If it doesn't, it will dynamically grow the table
by allocating an array twice as big and copying over the data to the new array.

~~~

Start implementing the `tgc_resize()` function

`calloc()` sets all the bytes we're allocating to 0. This sets all our pointers
to `NULL`, which means all slots are considered empty.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -1,5 +1,14 @@
|#include "tgc.h"
|
+/*** resize pointer table ***/
+
+static void tgc_resize(tgc_t *gc) {
+  if (gc->nslots >= gc->nitems) return;
+
+  gc->nslots = gc->nitems * 2;
+  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
+}
+
|/*** gc control ***/
|
|void tgc_start(tgc_t *gc) {

~~~

Copy the items in the old array to the new array

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -3,10 +3,15 @@
|/*** resize pointer table ***/
|
|static void tgc_resize(tgc_t *gc) {
+  tgc_ptr_t *old_items = gc->items;
+  size_t old_size = gc->nslots;
+
|  if (gc->nslots >= gc->nitems) return;
|
|  gc->nslots = gc->nitems * 2;
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
+
+  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
|}
|
|/*** gc control ***/

~~~

Include `<string.h>` to get `memcpy()`

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -2,6 +2,7 @@
|#define TGC_H
|
|#include <stdlib.h>
+#include <string.h>
|
|typedef struct {
|  void *ptr;

~~~

Free the old array

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -12,6 +12,8 @@
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
|
|  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
+
+  free(old_items);
|}
|
|/*** gc control ***/

~~~

## Actually adding to the pointer table

Now we want to implement the other non-existent function we used earlier,
`tgc_add_ptr()`. Because `tgc_add()` increments `gc->nitems` and calls
`tgc_resize()`, we can assume there is at least one empty slot in the array. So
All we have to do is loop through the array, find that empty slot, and fill it
with the pointer.

~~~

Implement `tgc_add_ptr()`

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -1,5 +1,21 @@
|#include "tgc.h"
|
+/*** pointer table operations ***/
+
+static void tgc_add_ptr(tgc_t *gc, void *ptr) {
+  tgc_ptr_t item;
+  size_t i;
+
+  item.ptr = ptr;
+
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].ptr == NULL) {
+      gc->items[i] = item;
+      return;
+    }
+  }
+}
+
|/*** resize pointer table ***/
|
|static void tgc_resize(tgc_t *gc) {

~~~

Prevent re-adding a pointer

((Do we really need to do this check now? When would a pointer ever be
double-added anyway? This won't work between the point where we start removing
pointers from the array and the point where we actually start using it a hash
table.))

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -13,6 +13,7 @@
|      gc->items[i] = item;
|      return;
|    }
+    if (gc->items[i].ptr == item.ptr) { return; }
|  }
|}
|

~~~

## Error handling

OK. Everything's now in place to keep track of pointers. Let's go back and do
some error handling.

Generally, the only errors we have to worry about in a garbage collector are
out-of-memory errors. We can detect these errors by checking if `malloc` (or
`calloc()`) returns `NULL`.

~~~

Check if `malloc()` returned `NULL` in `tgc_alloc()`

When `malloc()` returns `NULL`, we don't want to add anything to the pointer
table. We just want to return `NULL` ourselves and let the user handle the
out-of-memory error.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -51,6 +51,8 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
-  tgc_add(gc, ptr);
+  if (ptr != NULL) {
+    tgc_add(gc, ptr);
+  }
|  return ptr;
|}

~~~

Handle out-of-memory error in `tgc_resize()`

Um, this step should really be split up.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -19,18 +19,26 @@
|
|/*** resize pointer table ***/
|
-static void tgc_resize(tgc_t *gc) {
+static int tgc_resize(tgc_t *gc) {
|  tgc_ptr_t *old_items = gc->items;
|  size_t old_size = gc->nslots;
|
-  if (gc->nslots >= gc->nitems) return;
+  if (gc->nslots >= gc->nitems) return 1;
|
|  gc->nslots = gc->nitems * 2;
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
|
+  if (gc->items == NULL) {
+    gc->nslots = old_size;
+    gc->items = old_items;
+    return 0;
+  }
+
|  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
|
|  free(old_items);
+
+  return 1;
|}
|
|/*** gc control ***/

~~~

Handle failure of `tgc_resize()` in `tgc_add()`

Now we have to handle the `0` return value from `tgc_resize()` in `tgc_add()`.
If `tgc_resize()` failed, then calling `tgc_add_ptr()` is unsafe because the
array might be full. So in that case, we'll just free the allocated block of
memory and return `NULL` to tell `tgc_alloc()` that it failed.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -51,10 +51,17 @@
|
|/*** allocator functions ***/
|
-static void tgc_add(tgc_t *gc, void *ptr) {
+static void *tgc_add(tgc_t *gc, void *ptr) {
|  gc->nitems++;
-  tgc_resize(gc);
-  tgc_add_ptr(gc, ptr);
+
+  if (tgc_resize(gc)) {
+    tgc_add_ptr(gc, ptr);
+    return ptr;
+  } else {
+    gc->nitems--;
+    free(ptr);
+    return NULL;
+  }
|}
|
|void *tgc_alloc(tgc_t *gc, size_t size) {

~~~

Handle failure of `tgc_add()` in `tgc_alloc()`

`tgc_alloc()` should return the value that `tgc_add()` returns, so that if it
failed adding the pointer to the array (in which case it also freed the
pointer), we'll return `NULL` from `tgc_alloc()`. Otherwise, the allocated
pointer will be returned, as before.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -67,7 +67,7 @@
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {
-    tgc_add(gc, ptr);
+    ptr = tgc_add(gc, ptr);
|  }
|  return ptr;
|}

~~~

## Sweep

It's time to start implementing the sweep phase of our mark and sweep garbage
collector. For now, `tgc_sweep()` will simply free every pointer in the pointer
table, removing each one from the table as it goes.

~~~

Implement `tgc_sweep()`

If the `ptr` field is `NULL`, that means the slot is empty so we skip it.
`memset`ting the struct to `0`'s has the effect of setting `ptr` to `NULL`,
marking the slot as empty.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -41,6 +41,19 @@
|  return 1;
|}
|
+/*** mark and sweep ***/
+
+static void tgc_sweep(tgc_t *gc) {
+  size_t i;
+
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].ptr == NULL) { continue; }
+    free(gc->items[i].ptr);
+    memset(&gc->items[i], 0, sizeof(tgc_ptr_t));
+    gc->nitems--;
+  }
+}
+
|/*** gc control ***/
|
|void tgc_start(tgc_t *gc) {

~~~

Skip the sweep phase when there are no allocations

Garbage collection is expensive, so we should take any chance we get to skip an
entire phase like this.

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -46,6 +46,8 @@
|static void tgc_sweep(tgc_t *gc) {
|  size_t i;
|
+  if (gc->nitems == 0) { return; }
+
|  for (i = 0; i < gc->nslots; i++) {
|    if (gc->items[i].ptr == NULL) { continue; }
|    free(gc->items[i].ptr);

~~~

Add a function prototype for `tgc_stop()`

The user is expected to call `tgc_stop()` at the end of their program, or when
they are done using garbage collection. It should run the sweep phase to free
all allocated memory, and also free the memory used by the garbage collector's
internal structures (i.e. the pointer table).

diff --git a/tgc.h b/tgc.h
--- a/tgc.h
+++ b/tgc.h
@@ -14,6 +14,7 @@
|} tgc_t;
|
|void tgc_start(tgc_t *gc);
+void tgc_stop(tgc_t *gc);
|
|void *tgc_alloc(tgc_t *gc, size_t size);
|

~~~

Implement `tgc_stop()`

diff --git a/tgc.c b/tgc.c
--- a/tgc.c
+++ b/tgc.c
@@ -64,6 +64,11 @@
|  gc->items = NULL;
|}
|
+void tgc_stop(tgc_t *gc) {
+  tgc_sweep(gc);
+  free(gc->items);
+}
+
|/*** allocator functions ***/
|
|static void *tgc_add(tgc_t *gc, void *ptr) {

~~~

In the [next chapter](03.mark.html), we will implement the mark phase of our
mark and sweep garbage collector.

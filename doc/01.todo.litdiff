# Linked todo list

Alright, let's build a garbage collector together! :D

...um, so where do we begin with something like this?

Usually I like to build things in small, satisfying steps---to be able to run the code after making each change, and *see* the change in action.

This gets tricky when building a garbage collector. Garbage collectors are very behind-the-scenes. If they're doing their job well, they don't really have any observable effects to the user.

To gain visibility into our garbage collector, we'll use *print statements* to reveal what it's doing. We'll also build an *operator interface* into it, which prints out the entire state of the garbage collector when you type a secret command.

To test our garbage collector, we'll build a little todo app that stores the todo list as a linked list. Linked lists are an odd choice of data structure for a todo app, but it turns out they are perfect for testing a garbage collector!

So, in this chapter we'll start by building the todo app, *without* any garbage collection yet. That means we'll have to `free()` our memory manually. Manual memory management is painful, but this pain will give us motivation to start building our garbage collector in the next chapter.

## An interactive command line app

Our todo app will be very minimalist. It'll give the user an interactive prompt, which they can type commands into to add and remove todos. Adding todos will cause memory to be allocated, and removing todos will cause memory to become unused. This will provide a nice interactive way of testing our garbage collector.

Time to start typing! Create a file named `todo.c` and give it a `main()` function.

~~~ 1. main
--- /dev/null
+++ todo.c
@@ -0,0 +1,3 @@
+int main() {
+  return 0;
+}

This blank slate of a program will become our todo list app.

Let's add a `Makefile` to compile this program.

~~~ 2. makefile
--- /dev/null
+++ Makefile
@@ -0,0 +1,5 @@
+todo: todo.c
+	$(CC) todo.c -o todo
+
+clean:
+	rm -f todo

Now we can run `make todo` (or just `make`) to compile the todo app, and `make clean` to remove the compiled executable.

Next, we'll start reading input from the user in a loop. The first command we'll implement will be `q`, which will quit the program.

~~~ 3. q-to-quit
--- todo.c
+++ todo.c
@@ -1,3 +1,18 @@
+#include <stdio.h>
+
|int main() {
+  char input[1024];
+  int quitting = 0;
+
+  while (!quitting) {
+    if (fgets(input, sizeof(input) - 1, stdin)) {
+      switch (input[0]) {
+        case 'q':
+          quitting = 1;
+          break;
+      }
+    }
+  }
+
|  return 0;
|}

We're using `fgets()` to read a line from the standard input, into our `input` buffer. The first character of the user's input tells us which command they want to run. If it's `q`, the loop ends and we quit.

Let's print a `todo> ` prompt to make it clear that we're expecting them to type a command.

~~~ 4. prompt
--- todo.c
+++ todo.c
@@ -5,6 +5,9 @@
|  int quitting = 0;
|
|  while (!quitting) {
+    printf("todo> ");
+    fflush(stdout);
+
|    if (fgets(input, sizeof(input) - 1, stdin)) {
|      switch (input[0]) {
|        case 'q':

Terminals usually do line-buffered output, meaning they won't actually print anything to the screen until a newline is printed. Our prompt doesn't end in a newline, so we need to flush the standard output to make sure it actually shows up on the screen.

We should also handle end-of-file, as an alternative way of quitting. Users often expect to be able to press <kbd>Ctrl-D</kbd> to quit interactive prompts. It also allows you to use a file as input to the todo app, which could be useful for testing later.

~~~ 5. handle-eof
--- todo.c
+++ todo.c
@@ -15,6 +15,11 @@
|          break;
|      }
|    }
+
+    if (feof(stdin)) {
+      printf("\n");
+      quitting = 1;
+    }
|  }
|
|  return 0;

## Adding todos

The `+` command will add an item to the todo list. Anything coming after the `+` will be the **description** of the todo item. So a full command might look like `+Take the lettuce out of the drier`.

As I mentioned earlier, we're going to use a linked list data structure to store the todo list. Each todo item will contain the todo description (a string), and a pointer to the next todo item in the list. Let's make a `TodoItem` struct for this.

~~~ 6. todo-struct
--- todo.c
+++ todo.c
@@ -1,5 +1,10 @@
|#include <stdio.h>
|
+typedef struct TodoItem {
+  char* description;
+  struct TodoItem* next;
+} TodoItem;
+
|int main() {
|  char input[1024];
|  int quitting = 0;

Our todo list will then be a pointer to the first `TodoItem`, or `NULL` if the todo list is empty. Let's add a local variable to `main()` to keep track of our todo list, and initialize it to `NULL`.

~~~ 7. todo-list-head
--- todo.c
+++ todo.c
@@ -8,6 +8,7 @@
|int main() {
|  char input[1024];
|  int quitting = 0;
+  TodoItem* todo = NULL;
|
|  while (!quitting) {
|    printf("todo> ");

Next we'll handle the `+` command.

~~~ 8. call-todo-add
--- todo.c
+++ todo.c
@@ -16,6 +16,9 @@
|
|    if (fgets(input, sizeof(input) - 1, stdin)) {
|      switch (input[0]) {
+        case '+':
+          todo = todo_add(todo, &input[1]);
+          break;
|        case 'q':
|          quitting = 1;
|          break;

`todo_add()` will take the existing todo list, add a `TodoItem` to the front of it, and return that todo item as the new head of the list. That's why we both pass `todo` as an argument and then overwrite `todo` with the result.

So, let's implement `todo_add()`. It will have to allocate memory for the `TodoItem` struct, as well as the description string.

~~~ 9. todo-add
--- todo.c
+++ todo.c
@@ -5,6 +5,17 @@
|  struct TodoItem* next;
|} TodoItem;
|
+TodoItem* todo_add(TodoItem* todo, const char* description) {
+  TodoItem* todo_item = (TodoItem*)malloc(sizeof(TodoItem));
+  size_t len = strlen(description);
+
+  todo_item->next = todo;
+  todo_item->description = (char*)malloc(len + 1);
+  strcpy(todo_item->description, description);
+
+  return todo_item;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

We'll need to include a couple of headers to use `malloc()`, `strlen()`, and `strcpy()`.

~~~ 10. todo-includes
--- todo.c
+++ todo.c
@@ -1,4 +1,6 @@
|#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
|
|typedef struct TodoItem {
|  char* description;

With that, adding items to the todo list should work! Unfortunately we can't see the todo list, so we can't see this in action just yet. We'll take care of that next.

Notice that we used `malloc()` without using `free()`. Technically, our program is leaking memory. If you have `valgrind`, you can run `valgrind ./todo` to see this. Later, after we've implemented the rest of the features, we'll add in all the proper `free()`s.

## Printing the todo list

The todo list should be printed after every command the user runs. It will show an id number beside each todo item, to make it easy to refer to todo items when using the delete command.

Let's add a `todo_print()` function that traverses the linked list to print out the todo list.

~~~ 11. todo-print
--- todo.c
+++ todo.c
@@ -7,6 +7,19 @@
|  struct TodoItem* next;
|} TodoItem;
|
+void todo_print(TodoItem* todo) {
+  if (todo == NULL) {
+    printf("No todos! :D\n");
+  }
+
+  int id = 1;
+  while (todo) {
+    printf("%d. %s\n", id, todo->description);
+    todo = todo->next;
+    id++;
+  }
+}
+
|TodoItem* todo_add(TodoItem* todo, const char* description) {
|  TodoItem* todo_item = (TodoItem*)malloc(sizeof(TodoItem));
|  size_t len = strlen(description);

~~~ 12. call-todo-print
--- todo.c
+++ todo.c
@@ -37,6 +37,8 @@
|  TodoItem* todo = NULL;
|
|  while (!quitting) {
+    todo_print(todo);
+
|    printf("todo> ");
|    fflush(stdout);
|

~~~ 13. trim-trailing-newline
--- todo.c
+++ todo.c
@@ -43,6 +43,11 @@
|    fflush(stdout);
|
|    if (fgets(input, sizeof(input) - 1, stdin)) {
+      if (input[0]) {
+        // Trim trailing newline.
+        input[strlen(input) - 1] = '\0';
+      }
+
|      switch (input[0]) {
|        case '+':
|          todo = todo_add(todo, &input[1]);

~~~ 14. better-cli
--- todo.c
+++ todo.c
@@ -55,6 +55,11 @@
|        case 'q':
|          quitting = 1;
|          break;
+        case '\0':
+          break;
+        default:
+          printf("Invalid command.\nAvailable commands: + q\n\n");
+          break;
|      }
|    }
|

~~~ 15. call-todo-remove
--- todo.c
+++ todo.c
@@ -52,6 +52,9 @@
|        case '+':
|          todo = todo_add(todo, &input[1]);
|          break;
+        case '-':
+          todo = todo_remove(todo, atoi(&input[1]));
+          break;
|        case 'q':
|          quitting = 1;
|          break;

~~~ 16. remove-xs
--- todo.c
+++ todo.c
@@ -31,6 +31,23 @@
|  return todo_item;
|}
|
+TodoItem* todo_remove(TodoItem* todo, int index) {
+  int id = 1;
+  TodoItem* cur = todo;
+  while (cur) {
+    if (id == index - 1) {
+      if (cur->next) {
+        cur->next = cur->next->next;
+      }
+      break;
+    }
+    cur = cur->next;
+    id++;
+  }
+
+  return todo;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

~~~ 17. remove-x
--- todo.c
+++ todo.c
@@ -32,6 +32,10 @@
|}
|
|TodoItem* todo_remove(TodoItem* todo, int index) {
+  if (index == 1 && todo) {
+    return todo->next;
+  }
+
|  int id = 1;
|  TodoItem* cur = todo;
|  while (cur) {

~~~ 18. add-snip-command
--- todo.c
+++ todo.c
@@ -76,13 +76,16 @@
|        case '-':
|          todo = todo_remove(todo, atoi(&input[1]));
|          break;
+        case '/':
+          todo = todo_snip(todo, atoi(&input[1]));
+          break;
|        case 'q':
|          quitting = 1;
|          break;
|        case '\0':
|          break;
|        default:
-          printf("Invalid command.\nAvailable commands: + q\n\n");
+          printf("Invalid command.\nAvailable commands: + - / q\n\n");
|          break;
|      }
|    }

~~~ 19. snip-xs
--- todo.c
+++ todo.c
@@ -52,6 +52,21 @@
|  return todo;
|}
|
+TodoItem* todo_snip(TodoItem* todo, int index) {
+  int id = 1;
+  TodoItem* cur = todo;
+  while (cur) {
+    if (id == index - 1) {
+      cur->next = NULL;
+      break;
+    }
+    cur = cur->next;
+    id++;
+  }
+
+  return todo;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

~~~ 20. snip-x
--- todo.c
+++ todo.c
@@ -53,6 +53,10 @@
|}
|
|TodoItem* todo_snip(TodoItem* todo, int index) {
+  if (index <= 1) {
+    return NULL;
+  }
+
|  int id = 1;
|  TodoItem* cur = todo;
|  while (cur) {

~~~ 21. free-final-todo-list
--- todo.c
+++ todo.c
@@ -115,5 +115,14 @@
|    }
|  }
|
+  TodoItem* cur = todo;
+  while (cur) {
+    TodoItem* to_delete = cur;
+    cur = cur->next;
+
+    free(to_delete->description);
+    free(to_delete);
+  }
+
|  return 0;
|}

~~~ 22. free-remove-x
--- todo.c
+++ todo.c
@@ -33,7 +33,10 @@
|
|TodoItem* todo_remove(TodoItem* todo, int index) {
|  if (index == 1 && todo) {
-    return todo->next;
+    TodoItem* next = todo->next;
+    free(todo->description);
+    free(todo);
+    return next;
|  }
|
|  int id = 1;

~~~ 23. free-remove-xs
--- todo.c
+++ todo.c
@@ -44,7 +44,10 @@
|  while (cur) {
|    if (id == index - 1) {
|      if (cur->next) {
+        TodoItem* to_delete = cur->next;
|        cur->next = cur->next->next;
+        free(to_delete->description);
+        free(to_delete);
|      }
|      break;
|    }

~~~ 24. free-snip-x
--- todo.c
+++ todo.c
@@ -60,6 +60,12 @@
|
|TodoItem* todo_snip(TodoItem* todo, int index) {
|  if (index <= 1) {
+    while (todo) {
+      TodoItem* to_delete = todo;
+      todo = todo->next;
+      free(to_delete->description);
+      free(to_delete);
+    }
|    return NULL;
|  }
|

~~~ 25. free-snip-xs
--- todo.c
+++ todo.c
@@ -73,7 +73,14 @@
|  TodoItem* cur = todo;
|  while (cur) {
|    if (id == index - 1) {
+      TodoItem* to_snip = cur->next;
|      cur->next = NULL;
+      while (to_snip) {
+        TodoItem* to_delete = to_snip;
+        to_snip = to_snip->next;
+        free(to_delete->description);
+        free(to_delete);
+      }
|      break;
|    }
|    cur = cur->next;


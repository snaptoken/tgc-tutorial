# Linked todo list

Alright, let's build a garbage collector together! :D

...um, so where do we begin with something like this?

Usually I like to build things in small, satisfying steps---to be able to run the code after making each change, and *see* the change in action.

This gets tricky when building a garbage collector. Garbage collectors are very behind-the-scenes. If they're doing their job well, they don't really have any observable effects to the user.

To gain visibility into our garbage collector, we'll use *print statements* to reveal what it's doing. We'll also build an *operator interface* into it, which prints out the entire state of the garbage collector when you type a secret command.

To test our garbage collector, we'll build a little todo app that stores the todo list as a linked list. Linked lists are an odd choice of data structure for a todo app, but it turns out they are perfect for testing a garbage collector!

So, in this chapter we'll start by building the todo app, *without* any garbage collection yet. That means we'll have to `free()` our memory manually. Manual memory management is painful, but this pain will give us motivation to start building our garbage collector in the next chapter.

## An interactive command line app

Our todo app will be very minimalist. It'll give the user an interactive prompt, which they can type commands into to add and remove todos. Adding todos will cause memory to be allocated, and removing todos will cause memory to become unused. This will provide a nice interactive way of testing our garbage collector.

Time to start typing! Create a file named `todo.c` and give it a `main()` function.

~~~ 1. main
--- /dev/null
+++ todo.c
@@ -0,0 +1,3 @@
+int main() {
+  return 0;
+}

This blank slate of a program will become our todo list app.

Let's add a `Makefile` to compile this program.

~~~ 2. makefile
--- /dev/null
+++ Makefile
@@ -0,0 +1,5 @@
+todo: todo.c
+	$(CC) todo.c -o todo
+
+clean:
+	rm -f todo

Now we can run `make todo` (or just `make`) to compile the todo app, and `make clean` to remove the compiled executable.

Next, we'll start reading input from the user in a loop. The first command we'll implement will be `q`, which will quit the program.

~~~ 3. q-to-quit
--- todo.c
+++ todo.c
@@ -1,3 +1,18 @@
+#include <stdio.h>
+
|int main() {
+  char input[1024];
+  int quitting = 0;
+
+  while (!quitting) {
+    if (fgets(input, sizeof(input) - 1, stdin)) {
+      switch (input[0]) {
+        case 'q':
+          quitting = 1;
+          break;
+      }
+    }
+  }
+
|  return 0;
|}

We're using `fgets()` to read a line from the standard input, into our `input` buffer. The first character of the user's input tells us which command they want to run. If it's `q`, the loop ends and we quit.

Let's print a `todo> ` prompt to make it clear that we're expecting them to type a command.

~~~ 4. prompt
--- todo.c
+++ todo.c
@@ -5,6 +5,9 @@
|  int quitting = 0;
|
|  while (!quitting) {
+    printf("todo> ");
+    fflush(stdout);
+
|    if (fgets(input, sizeof(input) - 1, stdin)) {
|      switch (input[0]) {
|        case 'q':

Terminals usually do line-buffered output, meaning they won't actually print anything to the screen until a newline is printed. Our prompt doesn't end in a newline, so we need to flush the standard output to make sure it actually shows up on the screen.

We should also handle end-of-file, as an alternative way of quitting. Users often expect to be able to press <kbd>Ctrl-D</kbd> to quit interactive prompts. It also allows you to use a file as input to the todo app, which could be useful for testing later.

~~~ 5. handle-eof
--- todo.c
+++ todo.c
@@ -15,6 +15,11 @@
|          break;
|      }
|    }
+
+    if (feof(stdin)) {
+      printf("\n");
+      quitting = 1;
+    }
|  }
|
|  return 0;

## Adding todos

The `+` command will add an item to the todo list. Whatever comes after the `+` will be the description of the todo item. So you could write `+Take the lettuce out of the drier`.

As I mentioned earlier, we're going to store the todo list as a linked list. Each todo item will contain the todo description (a string), and a pointer to the next todo item in the list. Let's make a `TodoItem` struct for this.

~~~ 6. todo-struct
--- todo.c
+++ todo.c
@@ -1,5 +1,10 @@
|#include <stdio.h>
|
+typedef struct TodoItem {
+  char* description;
+  struct TodoItem* next;
+} TodoItem;
+
|int main() {
|  char input[1024];
|  int quitting = 0;

Now our todo list can be stored as a pointer to the first `TodoItem`, or `NULL` if the todo list is empty. Let's add a variable to `main()` to keep track of our todo list, and initialize it to `NULL`.

~~~ 7. todo-list-head
--- todo.c
+++ todo.c
@@ -8,6 +8,7 @@
|int main() {
|  char input[1024];
|  int quitting = 0;
+  TodoItem* todo = NULL;
|
|  while (!quitting) {
|    printf("todo> ");

Next we'll handle the `+` command.

~~~ 8. call-todo-add
--- todo.c
+++ todo.c
@@ -16,6 +16,9 @@
|
|    if (fgets(input, sizeof(input) - 1, stdin)) {
|      switch (input[0]) {
+        case '+':
+          todo = todo_add(todo, &input[1]);
+          break;
|        case 'q':
|          quitting = 1;
|          break;

`todo_add()` will take the existing todo list, add a `TodoItem` to the front of it, and return that todo item as the new head of the list. That's why we both pass `todo` as an argument and then overwrite `todo` with the result.

So, let's implement `todo_add()`. It will have to allocate memory for the `TodoItem` struct, as well as the description string.

~~~ 9. todo-add
--- todo.c
+++ todo.c
@@ -5,6 +5,17 @@
|  struct TodoItem* next;
|} TodoItem;
|
+TodoItem* todo_add(TodoItem* todo, const char* description) {
+  TodoItem* todo_item = (TodoItem*)malloc(sizeof(TodoItem));
+  size_t len = strlen(description);
+
+  todo_item->next = todo;
+  todo_item->description = (char*)malloc(len + 1);
+  strcpy(todo_item->description, description);
+
+  return todo_item;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

We'll need to include a couple of headers to use `malloc()`, `strlen()`, and `strcpy()`.

~~~ 10. todo-includes
--- todo.c
+++ todo.c
@@ -1,4 +1,6 @@
|#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
|
|typedef struct TodoItem {
|  char* description;

With that, adding items to the todo list should work! Unfortunately we can't see the todo list, so we can't see this in action just yet.

Notice that we used `malloc()` without using `free()`. Technically, our program is leaking memory now. If you have `valgrind`, you can run `valgrind ./todo` to how much memory leaked. Later, after we've implemented the rest of the features for our todo app, we'll add in all the proper `free()`s.

## Printing the todo list

The todo list should be printed after every command the user runs. It should show an id number beside each todo item, to make it easy to refer to todo items when using the delete command.

Let's add a `todo_print()` function that traverses the linked list to print out the todo list.

~~~ 11. todo-print
--- todo.c
+++ todo.c
@@ -7,6 +7,19 @@
|  struct TodoItem* next;
|} TodoItem;
|
+void todo_print(TodoItem* todo) {
+  if (todo == NULL) {
+    printf("No todos! :D\n");
+  }
+
+  int id = 1;
+  while (todo) {
+    printf("%d. %s\n", id, todo->description);
+    todo = todo->next;
+    id++;
+  }
+}
+
|TodoItem* todo_add(TodoItem* todo, const char* description) {
|  TodoItem* todo_item = (TodoItem*)malloc(sizeof(TodoItem));
|  size_t len = strlen(description);

Call it inside our main loop:

~~~ 12. call-todo-print
--- todo.c
+++ todo.c
@@ -37,6 +37,8 @@
|  TodoItem* todo = NULL;
|
|  while (!quitting) {
+    todo_print(todo);
+
|    printf("todo> ");
|    fflush(stdout);
|

Now you should see your todo items being added when you use the `+` command!

They're being printed with extra newlines though. The newline from the input string is being saved onto the todo item description. Let's trim the newline out so that doesn't happen.

~~~ 13. trim-trailing-newline
--- todo.c
+++ todo.c
@@ -43,6 +43,11 @@
|    fflush(stdout);
|
|    if (fgets(input, sizeof(input) - 1, stdin)) {
+      if (input[0]) {
+        // Trim trailing newline.
+        input[strlen(input) - 1] = '\0';
+      }
+
|      switch (input[0]) {
|        case '+':
|          todo = todo_add(todo, &input[1]);

Now that things are starting to come together, let's make the user experience a little better by detecting invalid commands and offering a little bit of help.

~~~ 14. better-cli
--- todo.c
+++ todo.c
@@ -55,6 +55,11 @@
|        case 'q':
|          quitting = 1;
|          break;
+        case '\0':
+          break;
+        default:
+          printf("Invalid command.\nAvailable commands: + q\n\n");
+          break;
|      }
|    }
|

## Removing todos

The command for removing a todo item will be `-`. The id of the todo you want to remove should come right after, e.g. `-3`.

~~~ 15. call-todo-remove
--- todo.c
+++ todo.c
@@ -52,6 +52,9 @@
|        case '+':
|          todo = todo_add(todo, &input[1]);
|          break;
+        case '-':
+          todo = todo_remove(todo, atoi(&input[1]));
+          break;
|        case 'q':
|          quitting = 1;
|          break;

`atoi()` (ascii to int) parses the number in the input string into an int. This gets passed to `todo_remove()`, which should remove the todo item with that id from the todo list.

Removing something from a linked list is hard. First we have to traverse the list until we get to the item we want to remove. Then we link the item that comes before it to the item that comes after it.

~~~ 16. remove-xs
--- todo.c
+++ todo.c
@@ -31,6 +31,23 @@
|  return todo_item;
|}
|
+TodoItem* todo_remove(TodoItem* todo, int index) {
+  int id = 1;
+  TodoItem* cur = todo;
+  while (cur) {
+    if (id == index - 1) {
+      if (cur->next) {
+        cur->next = cur->next->next;
+      }
+      break;
+    }
+    cur = cur->next;
+    id++;
+  }
+
+  return todo;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

This doesn't work for removing the first item of the list. We have to handle that as a special case. All we have to do for this case is making the second item of the list the new head of the list.

~~~ 17. remove-x
--- todo.c
+++ todo.c
@@ -32,6 +32,10 @@
|}
|
|TodoItem* todo_remove(TodoItem* todo, int index) {
+  if (index == 1 && todo) {
+    return todo->next;
+  }
+
|  int id = 1;
|  TodoItem* cur = todo;
|  while (cur) {

## The snip command

Let's add one more command: the snip command. This is similar to the remove command, but its symbol is `/` and it removes the given item and *all* of the items that come after it. This command is just a convenient way to create a bunch of garbage for the garbage collector to collect.

~~~ 18. add-snip-command
--- todo.c
+++ todo.c
@@ -76,13 +76,16 @@
|        case '-':
|          todo = todo_remove(todo, atoi(&input[1]));
|          break;
+        case '/':
+          todo = todo_snip(todo, atoi(&input[1]));
+          break;
|        case 'q':
|          quitting = 1;
|          break;
|        case '\0':
|          break;
|        default:
-          printf("Invalid command.\nAvailable commands: + q\n\n");
+          printf("Invalid command.\nAvailable commands: + - / q\n\n");
|          break;
|      }
|    }

`todo_snip()` will look similar to `todo_remove()`, except it will set the `->next` pointer to `NULL` to cut the list short at the specified id.

~~~ 19. snip-xs
--- todo.c
+++ todo.c
@@ -52,6 +52,21 @@
|  return todo;
|}
|
+TodoItem* todo_snip(TodoItem* todo, int index) {
+  int id = 1;
+  TodoItem* cur = todo;
+  while (cur) {
+    if (id == index - 1) {
+      cur->next = NULL;
+      break;
+    }
+    cur = cur->next;
+    id++;
+  }
+
+  return todo;
+}
+
|int main() {
|  char input[1024];
|  int quitting = 0;

If we're snipping at the first item, that means we're removing all of the items in the todo list. So in this case, we'll return `NULL` as the new head of the list.

~~~ 20. snip-x
--- todo.c
+++ todo.c
@@ -53,6 +53,10 @@
|}
|
|TodoItem* todo_snip(TodoItem* todo, int index) {
+  if (index <= 1) {
+    return NULL;
+  }
+
|  int id = 1;
|  TodoItem* cur = todo;
|  while (cur) {

Note that because `atoi()` returns `0` for an empty string, you can just type `/` without a number to clear the whole todo list.

## Plugging the memory leaks

~~~ 21. free-final-todo-list
--- todo.c
+++ todo.c
@@ -115,5 +115,14 @@
|    }
|  }
|
+  TodoItem* cur = todo;
+  while (cur) {
+    TodoItem* to_delete = cur;
+    cur = cur->next;
+
+    free(to_delete->description);
+    free(to_delete);
+  }
+
|  return 0;
|}

~~~ 22. free-remove-x
--- todo.c
+++ todo.c
@@ -33,7 +33,10 @@
|
|TodoItem* todo_remove(TodoItem* todo, int index) {
|  if (index == 1 && todo) {
-    return todo->next;
+    TodoItem* next = todo->next;
+    free(todo->description);
+    free(todo);
+    return next;
|  }
|
|  int id = 1;

~~~ 23. free-remove-xs
--- todo.c
+++ todo.c
@@ -44,7 +44,10 @@
|  while (cur) {
|    if (id == index - 1) {
|      if (cur->next) {
+        TodoItem* to_delete = cur->next;
|        cur->next = cur->next->next;
+        free(to_delete->description);
+        free(to_delete);
|      }
|      break;
|    }

~~~ 24. free-snip-x
--- todo.c
+++ todo.c
@@ -60,6 +60,12 @@
|
|TodoItem* todo_snip(TodoItem* todo, int index) {
|  if (index <= 1) {
+    while (todo) {
+      TodoItem* to_delete = todo;
+      todo = todo->next;
+      free(to_delete->description);
+      free(to_delete);
+    }
|    return NULL;
|  }
|

~~~ 25. free-snip-xs
--- todo.c
+++ todo.c
@@ -73,7 +73,14 @@
|  TodoItem* cur = todo;
|  while (cur) {
|    if (id == index - 1) {
+      TodoItem* to_snip = cur->next;
|      cur->next = NULL;
+      while (to_snip) {
+        TodoItem* to_delete = to_snip;
+        to_snip = to_snip->next;
+        free(to_delete->description);
+        free(to_delete);
+      }
|      break;
|    }
|    cur = cur->next;


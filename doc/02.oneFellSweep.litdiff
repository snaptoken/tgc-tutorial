# One Fell Sweep

In C, you have to manage your memory *manually*. You call `malloc()` to allocate
a block of memory, and when you are done with it you must `free()` it. This is
very tricky to do properly in large programs. The bugs that arise from manual
memory management tend to be disastrous and hard to track down.

`tgc` is a garbage collector (**T**iny **G**arbage **C**ollector). The purpose
of a garbage collector is to `free()` your memory for you, *automatically*. C
programs that use a garbage collector only have to call the allocator function,
and don't have to worry about when to free the memory.

In this chapter, we'll create an allocator function called `tgc_alloc()`. We
will keep track of each piece of memory that is allocated through this function.
When the garbage collector is stopped using `tgc_stop()`, we will `free()` all
of the memory that was allocated through `tgc_alloc()`.

It's a very basic start to building a mark and sweep garbage collector: freeing
all the memory at the end, in "one fell sweep". But it lays a foundation for the
next chapters, in which we'll build a proper mark phase and sweep phase for our
garbage collector.

## The allocator

`tgc` will consist of only two files: the source file (`tgc.c`) and the header
file (`tgc.h`). We'll start by creating both of these files, and implementing
the `tgc_alloc()` function as a wrapper for `malloc()`.

~~~ 1. Create `tgc.h` and declare `tgc_alloc()`
--- /dev/null
+++ tgc.h
@@ -0,0 +1,1 @@
+void *tgc_alloc(size_t size);

~~~ 2. Include `<stdlib.h>` to get the `size_t` type
--- tgc.h
+++ tgc.h
@@ -1,1 +1,3 @@
+#include <stdlib.h>
+
|void *tgc_alloc(size_t size);

~~~ 3. Wrap the header file in an [#include guard](https://en.wikipedia.org/wiki/Include_guard)
--- tgc.h
+++ tgc.h
@@ -1,3 +1,8 @@
+#ifndef TGC_H
+#define TGC_H
+
|#include <stdlib.h>
|
|void *tgc_alloc(size_t size);
+
+#endif

~~~ 4. Create `tgc.c` and implement `tgc_alloc()` as a wrapper for `malloc()`
--- /dev/null
+++ tgc.c
@@ -0,0 +1,4 @@
+void *tgc_alloc(size_t size) {
+  void *ptr = malloc(size);
+  return ptr;
+}

~~~ 5. Include the header file
--- tgc.c
+++ tgc.c
@@ -1,3 +1,5 @@
+#include "tgc.h"
+
|void *tgc_alloc(size_t size) {
|  void *ptr = malloc(size);
|  return ptr;

~~~ 6. Add an "allocator functions" section
--- tgc.c
+++ tgc.c
@@ -1,5 +1,7 @@
|#include "tgc.h"
|
+/*** allocator functions ***/
+
|void *tgc_alloc(size_t size) {
|  void *ptr = malloc(size);
|  return ptr;

## Pointer table

We'll need to keep track of each memory allocation made through `tgc_alloc()`.
We'll store each pointer, along with its associated metadata, in a pointer
table. For now, this will be a dynamically growing array of `tgc_ptr_t` structs.
The array will be stored in a global state struct called `tgc_t`, which will be
passed as the first argument to every function in our library.

~~~ 7. Add a `tgc_ptr_t` struct for storing metadata about an allocation
--- tgc.h
+++ tgc.h
@@ -3,6 +3,10 @@
|
|#include <stdlib.h>
|
+typedef struct {
+  void *ptr;
+} tgc_ptr_t;
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~ 8. Add a `tgc_t` struct to keep track of all allocations and other global state
--- tgc.h
+++ tgc.h
@@ -7,6 +7,11 @@
|  void *ptr;
|} tgc_ptr_t;
|
+typedef struct {
+  tgc_ptr_t *items;
+  size_t nitems, nslots;
+} tgc_t;
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~ 9. Declare `tgc_start()`
--- tgc.h
+++ tgc.h
@@ -12,6 +12,8 @@
|  size_t nitems, nslots;
|} tgc_t;
|
+void tgc_start(tgc_t *gc);
+
|void *tgc_alloc(size_t size);
|
|#endif

~~~ 10. In `tgc_start()`, initialize an empty pointer table
--- tgc.c
+++ tgc.c
@@ -1,5 +1,13 @@
|#include "tgc.h"
|
+/*** gc control ***/
+
+void tgc_start(tgc_t *gc) {
+  gc->nitems = 0;
+  gc->nslots = 0;
+  gc->items = NULL;
+}
+
|/*** allocator functions ***/
|
|void *tgc_alloc(size_t size) {

~~~ 11. Have `tgc_alloc()` prototype take global state
--- tgc.h
+++ tgc.h
@@ -14,6 +14,6 @@
|
|void tgc_start(tgc_t *gc);
|
-void *tgc_alloc(size_t size);
+void *tgc_alloc(tgc_t *gc, size_t size);
|
|#endif

~~~ 12. Have `tgc_alloc()` take global state
--- tgc.c
+++ tgc.c
@@ -10,7 +10,7 @@
|
|/*** allocator functions ***/
|
-void *tgc_alloc(size_t size) {
+void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  return ptr;
|}

~~~ 13. In `tgc_alloc()`, call `tgc_add()` to remember the allocated pointer
--- tgc.c
+++ tgc.c
@@ -12,5 +12,6 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
+  tgc_add(gc, ptr);
|  return ptr;
|}

~~~ 14. In `tgc_add()`, resize the pointer table and then add the pointer to it
--- tgc.c
+++ tgc.c
@@ -10,6 +10,12 @@
|
|/*** allocator functions ***/
|
+static void tgc_add(tgc_t *gc, void *ptr) {
+  gc->nitems++;
+  tgc_resize(gc);
+  tgc_add_ptr(gc, ptr);
+}
+
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  tgc_add(gc, ptr);

## Growing the array

~~~ 15. In `tgc_resize()`, double the size of the pointer table (if needed)
--- tgc.c
+++ tgc.c
@@ -1,5 +1,14 @@
|#include "tgc.h"
|
+/*** resize pointer table ***/
+
+static void tgc_resize(tgc_t *gc) {
+  if (gc->nslots >= gc->nitems) return;
+
+  gc->nslots = gc->nitems * 2;
+  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
+}
+
|/*** gc control ***/
|
|void tgc_start(tgc_t *gc) {

~~~ 16. Copy the items in the old array to the new array
--- tgc.c
+++ tgc.c
@@ -3,10 +3,15 @@
|/*** resize pointer table ***/
|
|static void tgc_resize(tgc_t *gc) {
+  tgc_ptr_t *old_items = gc->items;
+  size_t old_size = gc->nslots;
+
|  if (gc->nslots >= gc->nitems) return;
|
|  gc->nslots = gc->nitems * 2;
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
+
+  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
|}
|
|/*** gc control ***/

~~~ 17. Include `<string.h>` to get `memcpy()`
--- tgc.h
+++ tgc.h
@@ -2,6 +2,7 @@
|#define TGC_H
|
|#include <stdlib.h>
+#include <string.h>
|
|typedef struct {
|  void *ptr;

~~~ 18. Free the old array
--- tgc.c
+++ tgc.c
@@ -12,6 +12,8 @@
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
|
|  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
+
+  free(old_items);
|}
|
|/*** gc control ***/

## Actually adding to the pointer table

~~~ 19. In `tgc_add_ptr()`, insert the pointer in the first empty array slot
--- tgc.c
+++ tgc.c
@@ -1,5 +1,21 @@
|#include "tgc.h"
|
+/*** pointer table operations ***/
+
+static void tgc_add_ptr(tgc_t *gc, void *ptr) {
+  tgc_ptr_t item;
+  size_t i;
+
+  item.ptr = ptr;
+
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].ptr == NULL) {
+      gc->items[i] = item;
+      return;
+    }
+  }
+}
+
|/*** resize pointer table ***/
|
|static void tgc_resize(tgc_t *gc) {

~~~ 20. Prevent re-adding a pointer
--- tgc.c
+++ tgc.c
@@ -13,6 +13,7 @@
|      gc->items[i] = item;
|      return;
|    }
+    if (gc->items[i].ptr == item.ptr) { return; }
|  }
|}
|

## Error handling

~~~ 21. Check if `malloc()` returned `NULL` in `tgc_alloc()`
--- tgc.c
+++ tgc.c
@@ -51,6 +51,8 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
-  tgc_add(gc, ptr);
+  if (ptr != NULL) {
+    tgc_add(gc, ptr);
+  }
|  return ptr;
|}

~~~ 22. Handle out-of-memory error in `tgc_resize()`
--- tgc.c
+++ tgc.c
@@ -19,18 +19,26 @@
|
|/*** resize pointer table ***/
|
-static void tgc_resize(tgc_t *gc) {
+static int tgc_resize(tgc_t *gc) {
|  tgc_ptr_t *old_items = gc->items;
|  size_t old_size = gc->nslots;
|
-  if (gc->nslots >= gc->nitems) return;
+  if (gc->nslots >= gc->nitems) return 1;
|
|  gc->nslots = gc->nitems * 2;
|  gc->items = calloc(gc->nslots, sizeof(tgc_ptr_t));
|
+  if (gc->items == NULL) {
+    gc->nslots = old_size;
+    gc->items = old_items;
+    return 0;
+  }
+
|  memcpy(gc->items, old_items, old_size * sizeof(tgc_ptr_t));
|
|  free(old_items);
+
+  return 1;
|}
|
|/*** gc control ***/

~~~ 23. Handle failure of `tgc_resize()` in `tgc_add()`
--- tgc.c
+++ tgc.c
@@ -51,10 +51,17 @@
|
|/*** allocator functions ***/
|
-static void tgc_add(tgc_t *gc, void *ptr) {
+static void *tgc_add(tgc_t *gc, void *ptr) {
|  gc->nitems++;
-  tgc_resize(gc);
-  tgc_add_ptr(gc, ptr);
+
+  if (tgc_resize(gc)) {
+    tgc_add_ptr(gc, ptr);
+    return ptr;
+  } else {
+    gc->nitems--;
+    free(ptr);
+    return NULL;
+  }
|}
|
|void *tgc_alloc(tgc_t *gc, size_t size) {

~~~ 24. Handle failure of `tgc_add()` in `tgc_alloc()`
--- tgc.c
+++ tgc.c
@@ -67,7 +67,7 @@
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {
-    tgc_add(gc, ptr);
+    ptr = tgc_add(gc, ptr);
|  }
|  return ptr;
|}

## Sweep

~~~ 25. Write `tgc_sweep()` to free all pointers in the pointer table
--- tgc.c
+++ tgc.c
@@ -41,6 +41,19 @@
|  return 1;
|}
|
+/*** mark and sweep ***/
+
+static void tgc_sweep(tgc_t *gc) {
+  size_t i;
+
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].ptr == NULL) { continue; }
+    free(gc->items[i].ptr);
+    memset(&gc->items[i], 0, sizeof(tgc_ptr_t));
+    gc->nitems--;
+  }
+}
+
|/*** gc control ***/
|
|void tgc_start(tgc_t *gc) {

~~~ 26. Skip the sweep phase when there are no allocations
--- tgc.c
+++ tgc.c
@@ -46,6 +46,8 @@
|static void tgc_sweep(tgc_t *gc) {
|  size_t i;
|
+  if (gc->nitems == 0) { return; }
+
|  for (i = 0; i < gc->nslots; i++) {
|    if (gc->items[i].ptr == NULL) { continue; }
|    free(gc->items[i].ptr);

~~~ 27. Declare `tgc_stop()`
--- tgc.h
+++ tgc.h
@@ -14,6 +14,7 @@
|} tgc_t;
|
|void tgc_start(tgc_t *gc);
+void tgc_stop(tgc_t *gc);
|
|void *tgc_alloc(tgc_t *gc, size_t size);
|

~~~ 28. Implement `tgc_stop()` to free all allocated memory, including the global state
--- tgc.c
+++ tgc.c
@@ -64,6 +64,11 @@
|  gc->items = NULL;
|}
|
+void tgc_stop(tgc_t *gc) {
+  tgc_sweep(gc);
+  free(gc->items);
+}
+
|/*** allocator functions ***/
|
|static void *tgc_add(tgc_t *gc, void *ptr) {

In the [next chapter](03.mark.html), we will implement the mark phase of our
mark and sweep garbage collector.

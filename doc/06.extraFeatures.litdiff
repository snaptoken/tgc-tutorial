# Extra Features

~~~ 99. change-mark-to-flags
--- tgc.h
+++ tgc.h
@@ -6,9 +6,13 @@
|#include <stdlib.h>
|#include <string.h>
|
+enum {
+  TGC_MARK = 0x01
+};
+
|typedef struct {
|  void *ptr;
-  int mark;
+  int flags;
|  size_t size, hash;
|} tgc_ptr_t;
|

~~~ 100. add-ptr-flags
--- tgc.c
+++ tgc.c
@@ -12,14 +12,14 @@
|  return v;
|}
|
-static void tgc_add_ptr(tgc_t *gc, void *ptr, size_t size) {
+static void tgc_add_ptr(tgc_t *gc, void *ptr, size_t size, int flags) {
|  tgc_ptr_t item, tmp;
|  size_t i, j, h, p;
|
|  i = tgc_hash(ptr) % gc->nslots; j = 0;
|
|  item.ptr = ptr;
-  item.mark = 0;
+  item.flags = flags;
|  item.size = size;
|  item.hash = i+1;
|

~~~ 101. rehash-flags
--- tgc.c
+++ tgc.c
@@ -82,7 +82,7 @@
|
|  for (i = 0; i < old_size; i++) {
|    if (old_items[i].hash != 0) {
-      tgc_add_ptr(gc, old_items[i].ptr, old_items[i].size);
+      tgc_add_ptr(gc, old_items[i].ptr, old_items[i].size, old_items[i].flags);
|    }
|  }
|

~~~ 102. add-flags
--- tgc.c
+++ tgc.c
@@ -229,7 +229,7 @@
|
|/*** allocator functions ***/
|
-static void *tgc_add(tgc_t *gc, void *ptr, size_t size) {
+static void *tgc_add(tgc_t *gc, void *ptr, size_t size, int flags) {
|  gc->nitems++;
|  gc->maxptr = ((uintptr_t)ptr) + size > gc->maxptr ?
|    ((uintptr_t)ptr) + size : gc->maxptr;
@@ -237,7 +237,7 @@
|    ((uintptr_t)ptr)        : gc->minptr;
|
|  if (tgc_resize_more(gc)) {
-    tgc_add_ptr(gc, ptr, size);
+    tgc_add_ptr(gc, ptr, size, flags);
|    if (!gc->paused && gc->nitems > gc->mitems) {
|      tgc_run(gc);
|    }

~~~ 103. zero-flags
--- tgc.c
+++ tgc.c
@@ -252,7 +252,7 @@
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {
-    ptr = tgc_add(gc, ptr, size);
+    ptr = tgc_add(gc, ptr, size, 0);
|  }
|  return ptr;
|}

~~~ 104. mark-ptr-flags
--- tgc.c
+++ tgc.c
@@ -117,8 +117,8 @@
|    h = gc->items[i].hash;
|    if (h == 0 || j > tgc_probe(gc, i, h)) { return; }
|    if (ptr == gc->items[i].ptr) {
-      if (gc->items[i].mark) { return; }
-      gc->items[i].mark = 1;
+      if (gc->items[i].flags & TGC_MARK) { return; }
+      gc->items[i].flags |= TGC_MARK;
|      for (k = 0; k < gc->items[i].size/sizeof(void*); k++) {
|        tgc_mark_ptr(gc, ((void**)gc->items[i].ptr)[k]);
|      }

~~~ 105. sweep-flags
--- tgc.c
+++ tgc.c
@@ -164,8 +164,8 @@
|
|  i = 0;
|  while (i < gc->nslots) {
-    if (gc->items[i].hash == 0) { i++; continue; }
-    if (gc->items[i].mark)      { i++; continue; }
+    if (gc->items[i].hash ==        0) { i++; continue; }
+    if (gc->items[i].flags & TGC_MARK) { i++; continue; }
|
|    free(gc->items[i].ptr);
|    memset(&gc->items[i], 0, sizeof(tgc_ptr_t));

~~~ 106. sweep-reset-mark-flag
--- tgc.c
+++ tgc.c
@@ -186,7 +186,7 @@
|  }
|
|  for (i = 0; i < gc->nslots; i++) {
-    gc->items[i].mark = 0;
+    gc->items[i].flags &= ~TGC_MARK;
|  }
|
|  tgc_resize_less(gc);

~~~ 107. add-root-flag
--- tgc.h
+++ tgc.h
@@ -7,7 +7,8 @@
|#include <string.h>
|
|enum {
-  TGC_MARK = 0x01
+  TGC_MARK = 0x01,
+  TGC_ROOT = 0x02
|};
|
|typedef struct {

~~~ 108. mark-roots
--- tgc.c
+++ tgc.c
@@ -146,12 +146,24 @@
|}
|
|static void tgc_mark(tgc_t *gc) {
+  size_t i, k;
|  jmp_buf env;
|
|  void (*volatile mark_stack)(tgc_t*) = tgc_mark_stack;
|
|  if (gc->nitems == 0) { return; }
|
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].hash ==        0) { continue; }
+    if (gc->items[i].flags & TGC_MARK) { continue; }
+    if (gc->items[i].flags & TGC_ROOT) {
+      gc->items[i].flags |= TGC_MARK;
+      for (k = 0; k < gc->items[i].size/sizeof(void*); k++) {
+        tgc_mark_ptr(gc, ((void**)gc->items[i].ptr)[k]);
+      }
+    }
+  }
+
|  memset(&env, 0, sizeof(jmp_buf));
|  setjmp(env);
|  mark_stack(gc);

~~~ 109. sweep-skip-roots
--- tgc.c
+++ tgc.c
@@ -178,6 +178,7 @@
|  while (i < gc->nslots) {
|    if (gc->items[i].hash ==        0) { i++; continue; }
|    if (gc->items[i].flags & TGC_MARK) { i++; continue; }
+    if (gc->items[i].flags & TGC_ROOT) { i++; continue; }
|
|    free(gc->items[i].ptr);
|    memset(&gc->items[i], 0, sizeof(tgc_ptr_t));

~~~ 110. alloc-opt-prototype
--- tgc.h
+++ tgc.h
@@ -34,4 +34,6 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size);
|
+void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags);
+
|#endif

~~~ 111. alloc-opt
--- tgc.c
+++ tgc.c
@@ -262,10 +262,10 @@
|  }
|}
|
-void *tgc_alloc(tgc_t *gc, size_t size) {
+void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {
-    ptr = tgc_add(gc, ptr, size, 0);
+    ptr = tgc_add(gc, ptr, size, flags);
|  }
|  return ptr;
|}

~~~ 112. alloc-delegates
--- tgc.c
+++ tgc.c
@@ -262,6 +262,10 @@
|  }
|}
|
+void *tgc_alloc(tgc_t *gc, size_t size) {
+  return tgc_alloc_opt(gc, size, 0);
+}
+
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {

~~~ 113. get-set-flags-prototypes
--- tgc.h
+++ tgc.h
@@ -36,4 +36,7 @@
|
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags);
|
+int tgc_get_flags(tgc_t *gc, void *ptr);
+void tgc_set_flags(tgc_t *gc, void *ptr, int flags);
+
|#endif

~~~ 114. get-set-flags
--- tgc.c
+++ tgc.c
@@ -273,3 +273,16 @@
|  }
|  return ptr;
|}
+
+/*** getters and setters ***/
+
+int tgc_get_flags(tgc_t *gc, void *ptr) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) { return p->flags; }
+  return 0;
+}
+
+void tgc_set_flags(tgc_t *gc, void *ptr, int flags) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) { p->flags = flags; }
+}

~~~ 115. get-ptr
--- tgc.c
+++ tgc.c
@@ -12,6 +12,18 @@
|  return v;
|}
|
+static tgc_ptr_t *tgc_get_ptr(tgc_t *gc, void *ptr) {
+  size_t i, j, h;
+  i = tgc_hash(ptr) % gc->nslots; j = 0;
+  while (1) {
+    h = gc->items[i].hash;
+    if (h == 0 || j > tgc_probe(gc, i, h)) { return NULL; }
+    if (gc->items[i].ptr == ptr) { return &gc->items[i]; }
+    i = (i+1) % gc->nslots; j++;
+  }
+  return NULL;
+}
+
|static void tgc_add_ptr(tgc_t *gc, void *ptr, size_t size, int flags) {
|  tgc_ptr_t item, tmp;
|  size_t i, j, h, p;

~~~ 116. get-size-prototype
--- tgc.h
+++ tgc.h
@@ -38,5 +38,6 @@
|
|int tgc_get_flags(tgc_t *gc, void *ptr);
|void tgc_set_flags(tgc_t *gc, void *ptr, int flags);
+size_t tgc_get_size(tgc_t *gc, void *ptr);
|
|#endif

~~~ 117. get-size
--- tgc.c
+++ tgc.c
@@ -298,3 +298,9 @@
|  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
|  if (p) { p->flags = flags; }
|}
+
+size_t tgc_get_size(tgc_t *gc, void *ptr) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) { return p->size; }
+  return 0;
+}

~~~ 118. add-leaf-flag
--- tgc.h
+++ tgc.h
@@ -8,7 +8,8 @@
|
|enum {
|  TGC_MARK = 0x01,
-  TGC_ROOT = 0x02
+  TGC_ROOT = 0x02,
+  TGC_LEAF = 0x04
|};
|
|typedef struct {

~~~ 119. mark-ptr-leaf
--- tgc.c
+++ tgc.c
@@ -131,6 +131,7 @@
|    if (ptr == gc->items[i].ptr) {
|      if (gc->items[i].flags & TGC_MARK) { return; }
|      gc->items[i].flags |= TGC_MARK;
+      if (gc->items[i].flags & TGC_LEAF) { return; }
|      for (k = 0; k < gc->items[i].size/sizeof(void*); k++) {
|        tgc_mark_ptr(gc, ((void**)gc->items[i].ptr)[k]);
|      }

~~~ 120. mark-leaf
--- tgc.c
+++ tgc.c
@@ -171,6 +171,7 @@
|    if (gc->items[i].flags & TGC_MARK) { continue; }
|    if (gc->items[i].flags & TGC_ROOT) {
|      gc->items[i].flags |= TGC_MARK;
+      if (gc->items[i].flags & TGC_LEAF) { continue; }
|      for (k = 0; k < gc->items[i].size/sizeof(void*); k++) {
|        tgc_mark_ptr(gc, ((void**)gc->items[i].ptr)[k]);
|      }

~~~ 121. add-dtor
--- tgc.h
+++ tgc.h
@@ -16,6 +16,7 @@
|  void *ptr;
|  int flags;
|  size_t size, hash;
+  void (*dtor)(void*);
|} tgc_ptr_t;
|
|typedef struct {

~~~ 122. alloc-opt-dtor-prototype
--- tgc.h
+++ tgc.h
@@ -36,7 +36,7 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size);
|
-void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags);
+void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*));
|
|int tgc_get_flags(tgc_t *gc, void *ptr);
|void tgc_set_flags(tgc_t *gc, void *ptr, int flags);

~~~ 123. alloc-opt-dtor
--- tgc.c
+++ tgc.c
@@ -280,10 +280,10 @@
|  return tgc_alloc_opt(gc, size, 0);
|}
|
-void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags) {
+void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*)) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {
-    ptr = tgc_add(gc, ptr, size, flags);
+    ptr = tgc_add(gc, ptr, size, flags, dtor);
|  }
|  return ptr;
|}

~~~ 124. alloc-dtor
--- tgc.c
+++ tgc.c
@@ -277,7 +277,7 @@
|}
|
|void *tgc_alloc(tgc_t *gc, size_t size) {
-  return tgc_alloc_opt(gc, size, 0);
+  return tgc_alloc_opt(gc, size, 0, NULL);
|}
|
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*)) {

~~~ 125. add-pass-dtor
--- tgc.c
+++ tgc.c
@@ -256,7 +256,10 @@
|
|/*** allocator functions ***/
|
-static void *tgc_add(tgc_t *gc, void *ptr, size_t size, int flags) {
+static void *tgc_add(
+  tgc_t *gc, void *ptr, size_t size,
+  int flags, void(*dtor)(void*)
+) {
|  gc->nitems++;
|  gc->maxptr = ((uintptr_t)ptr) + size > gc->maxptr ?
|    ((uintptr_t)ptr) + size : gc->maxptr;
@@ -264,7 +267,7 @@
|    ((uintptr_t)ptr)        : gc->minptr;
|
|  if (tgc_resize_more(gc)) {
-    tgc_add_ptr(gc, ptr, size, flags);
+    tgc_add_ptr(gc, ptr, size, flags, dtor);
|    if (!gc->paused && gc->nitems > gc->mitems) {
|      tgc_run(gc);
|    }

~~~ 126. set-dtor
--- tgc.c
+++ tgc.c
@@ -24,7 +24,10 @@
|  return NULL;
|}
|
-static void tgc_add_ptr(tgc_t *gc, void *ptr, size_t size, int flags) {
+static void tgc_add_ptr(
+  tgc_t *gc, void *ptr, size_t size,
+  int flags, void(*dtor)(void*)
+) {
|  tgc_ptr_t item, tmp;
|  size_t i, j, h, p;
|
@@ -34,6 +37,7 @@
|  item.flags = flags;
|  item.size = size;
|  item.hash = i+1;
+  item.dtor = dtor;
|
|  while (1) {
|    h = gc->items[i].hash;

~~~ 127. rehash-dtor
--- tgc.c
+++ tgc.c
@@ -98,7 +98,9 @@
|
|  for (i = 0; i < old_size; i++) {
|    if (old_items[i].hash != 0) {
-      tgc_add_ptr(gc, old_items[i].ptr, old_items[i].size, old_items[i].flags);
+      tgc_add_ptr(gc,
+        old_items[i].ptr, old_items[i].size,
+        old_items[i].flags, old_items[i].dtor);
|    }
|  }
|

~~~ 128. get-set-dtor-prototypes
--- tgc.h
+++ tgc.h
@@ -40,6 +40,8 @@
|
|int tgc_get_flags(tgc_t *gc, void *ptr);
|void tgc_set_flags(tgc_t *gc, void *ptr, int flags);
+void(*tgc_get_dtor(tgc_t *gc, void *ptr))(void*);
+void tgc_set_dtor(tgc_t *gc, void *ptr, void(*dtor)(void*));
|size_t tgc_get_size(tgc_t *gc, void *ptr);
|
|#endif

~~~ 129. get-set-dtor
--- tgc.c
+++ tgc.c
@@ -310,6 +310,17 @@
|  if (p) { p->flags = flags; }
|}
|
+void(*tgc_get_dtor(tgc_t *gc, void *ptr))(void*) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) { return p->dtor; }
+  return NULL;
+}
+
+void tgc_set_dtor(tgc_t *gc, void *ptr, void(*dtor)(void*)) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) { p->dtor = dtor; }
+}
+
|size_t tgc_get_size(tgc_t *gc, void *ptr) {
|  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
|  if (p) { return p->size; }

~~~ 130. add-frees
--- tgc.h
+++ tgc.h
@@ -23,9 +23,9 @@
|  void *bottom;
|  int paused;
|  uintptr_t minptr, maxptr;
-  tgc_ptr_t *items;
+  tgc_ptr_t *items, *frees;
|  double loadfactor, sweepfactor;
-  size_t nitems, nslots, mitems;
+  size_t nitems, nslots, mitems, nfrees;
|} tgc_t;
|
|void tgc_start(tgc_t *gc, void *stk);

~~~ 131. init-frees
--- tgc.c
+++ tgc.c
@@ -235,7 +235,9 @@
|  gc->nitems = 0;
|  gc->nslots = 0;
|  gc->mitems = 0;
+  gc->nfrees = 0;
|  gc->items = NULL;
+  gc->frees = NULL;
|  gc->minptr = UINTPTR_MAX;
|  gc->maxptr = 0;
|  gc->loadfactor = 0.9;

~~~ 132. stop-frees
--- tgc.c
+++ tgc.c
@@ -247,6 +247,7 @@
|void tgc_stop(tgc_t *gc) {
|  tgc_sweep(gc);
|  free(gc->items);
+  free(gc->frees);
|}
|
|void tgc_pause(tgc_t *gc) {

~~~ 133. sweep-count-frees
--- tgc.c
+++ tgc.c
@@ -194,6 +194,14 @@
|
|  if (gc->nitems == 0) { return; }
|
+  gc->nfrees = 0;
+  for (i = 0; i < gc->nslots; i++) {
+    if (gc->items[i].hash ==        0) { continue; }
+    if (gc->items[i].flags & TGC_MARK) { continue; }
+    if (gc->items[i].flags & TGC_ROOT) { continue; }
+    gc->nfrees++;
+  }
+
|  i = 0;
|  while (i < gc->nslots) {
|    if (gc->items[i].hash ==        0) { i++; continue; }

~~~ 134. sweep-alloc-frees
--- tgc.c
+++ tgc.c
@@ -202,6 +202,9 @@
|    gc->nfrees++;
|  }
|
+  gc->frees = realloc(gc->frees, sizeof(tgc_ptr_t) * gc->nfrees);
+  if (gc->frees == NULL) { return; }
+
|  i = 0;
|  while (i < gc->nslots) {
|    if (gc->items[i].hash ==        0) { i++; continue; }

~~~ 135. sweep-add-to-frees
--- tgc.c
+++ tgc.c
@@ -190,7 +190,7 @@
|}
|
|static void tgc_sweep(tgc_t *gc) {
-  size_t i, j, nj, nh;
+  size_t i, j, k, nj, nh;
|
|  if (gc->nitems == 0) { return; }
|
@@ -205,13 +205,13 @@
|  gc->frees = realloc(gc->frees, sizeof(tgc_ptr_t) * gc->nfrees);
|  if (gc->frees == NULL) { return; }
|
-  i = 0;
+  i = 0; k = 0;
|  while (i < gc->nslots) {
|    if (gc->items[i].hash ==        0) { i++; continue; }
|    if (gc->items[i].flags & TGC_MARK) { i++; continue; }
|    if (gc->items[i].flags & TGC_ROOT) { i++; continue; }
|
-    free(gc->items[i].ptr);
+    gc->frees[k] = gc->items[i]; k++;
|    memset(&gc->items[i], 0, sizeof(tgc_ptr_t));
|
|    j = i;

~~~ 136. sweep-free-frees
--- tgc.c
+++ tgc.c
@@ -236,6 +236,11 @@
|  tgc_resize_less(gc);
|
|  gc->mitems = gc->nitems + (size_t)(gc->nitems * gc->sweepfactor) + 1;
+
+  for (i = 0; i < gc->nfrees; i++) {
+    if (gc->frees[i].dtor) { gc->frees[i].dtor(gc->frees[i].ptr); }
+    free(gc->frees[i].ptr);
+  }
|}
|
|/*** gc control ***/

~~~ 137. sweep-cleanup-frees
--- tgc.c
+++ tgc.c
@@ -241,6 +241,10 @@
|    if (gc->frees[i].dtor) { gc->frees[i].dtor(gc->frees[i].ptr); }
|    free(gc->frees[i].ptr);
|  }
+
+  free(gc->frees);
+  gc->frees = NULL;
+  gc->nfrees = 0;
|}
|
|/*** gc control ***/

~~~ 138. calloc-prototypes
--- tgc.h
+++ tgc.h
@@ -35,8 +35,11 @@
|void tgc_run(tgc_t *gc);
|
|void *tgc_alloc(tgc_t *gc, size_t size);
+void *tgc_calloc(tgc_t *gc, size_t num, size_t size);
|
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*));
+void *tgc_calloc_opt(tgc_t *gc, size_t num, size_t size, int flags,
+                     void(*dtor)(void*));
|
|int tgc_get_flags(tgc_t *gc, void *ptr);
|void tgc_set_flags(tgc_t *gc, void *ptr, int flags);

~~~ 139. calloc-opt
--- tgc.c
+++ tgc.c
@@ -320,6 +320,17 @@
|  return ptr;
|}
|
+void *tgc_calloc_opt(
+  tgc_t *gc, size_t num, size_t size,
+  int flags, void(*dtor)(void*)
+) {
+  void *ptr = calloc(num, size);
+  if (ptr != NULL) {
+    ptr = tgc_add(gc, ptr, num * size, flags, dtor);
+  }
+  return ptr;
+}
+
|/*** getters and setters ***/
|
|int tgc_get_flags(tgc_t *gc, void *ptr) {

~~~ 140. calloc
--- tgc.c
+++ tgc.c
@@ -312,6 +312,10 @@
|  return tgc_alloc_opt(gc, size, 0, NULL);
|}
|
+void *tgc_calloc(tgc_t *gc, size_t num, size_t size) {
+  return tgc_calloc_opt(gc, num, size, 0, NULL);
+}
+
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*)) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {

~~~ 141. realloc-prototype
--- tgc.h
+++ tgc.h
@@ -36,6 +36,7 @@
|
|void *tgc_alloc(tgc_t *gc, size_t size);
|void *tgc_calloc(tgc_t *gc, size_t num, size_t size);
+void *tgc_realloc(tgc_t *gc, void *ptr, size_t size);
|
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*));
|void *tgc_calloc_opt(tgc_t *gc, size_t num, size_t size, int flags,

~~~ 142. realloc
--- tgc.c
+++ tgc.c
@@ -316,6 +316,28 @@
|  return tgc_calloc_opt(gc, num, size, 0, NULL);
|}
|
+void *tgc_realloc(tgc_t *gc, void *ptr, size_t size) {
+  tgc_ptr_t *p;
+  void *qtr = realloc(ptr, size);
+
+  p = tgc_get_ptr(gc, ptr);
+
+  if (p && qtr == ptr) {
+    p->size = size;
+    return qtr;
+  }
+
+  if (p && qtr != ptr) {
+    int flags = p->flags;
+    void(*dtor)(void*) = p->dtor;
+    tgc_rem(gc, ptr);
+    tgc_add(gc, qtr, size, flags, dtor);
+    return qtr;
+  }
+
+  return NULL;
+}
+
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*)) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {

~~~ 143. rem
--- tgc.c
+++ tgc.c
@@ -308,6 +308,12 @@
|  }
|}
|
+static void tgc_rem(tgc_t *gc, void *ptr) {
+  tgc_rem_ptr(gc, ptr);
+  tgc_resize_less(gc);
+  gc->mitems = gc->nitems + (size_t)(gc->nitems * gc->sweepfactor) + 1;
+}
+
|void *tgc_alloc(tgc_t *gc, size_t size) {
|  return tgc_alloc_opt(gc, size, 0, NULL);
|}

~~~ 144. rem-ptr
--- tgc.c
+++ tgc.c
@@ -54,6 +54,25 @@
|  }
|}
|
+static void tgc_rem_ptr(tgc_t *gc, void *ptr) {
+  size_t i, j, h;
+
+  if (gc->nitems == 0) { return; }
+
+  i = tgc_hash(ptr) % gc->nslots; j = 0;
+
+  while (1) {
+    h = gc->items[i].hash;
+    if (h == 0 || j > tgc_probe(gc, i, h)) { return; }
+    if (gc->items[i].ptr == ptr) {
+      memset(&gc->items[i], 0, sizeof(tgc_ptr_t));
+      gc->nitems--;
+      return;
+    }
+    i = (i+1) % gc->nslots; j++;
+  }
+}
+
|/*** resize pointer table ***/
|
|enum {

~~~ 145. rem-ptr-linear-probing-invariant
--- tgc.c
+++ tgc.c
@@ -55,7 +55,7 @@
|}
|
|static void tgc_rem_ptr(tgc_t *gc, void *ptr) {
-  size_t i, j, h;
+  size_t i, j, h, nj, nh;
|
|  if (gc->nitems == 0) { return; }
|
@@ -66,6 +66,18 @@
|    if (h == 0 || j > tgc_probe(gc, i, h)) { return; }
|    if (gc->items[i].ptr == ptr) {
|      memset(&gc->items[i], 0, sizeof(tgc_ptr_t));
+      j = i;
+      while (1) {
+        nj = (j+1) % gc->nslots;
+        nh = gc->items[nj].hash;
+        if (nh != 0 && tgc_probe(gc, nj, nh) > 0) {
+          memcpy(&gc->items[ j], &gc->items[nj], sizeof(tgc_ptr_t));
+          memset(&gc->items[nj],              0, sizeof(tgc_ptr_t));
+          j = nj;
+        } else {
+          break;
+        }
+      }
|      gc->nitems--;
|      return;
|    }

~~~ 146. realloc-handle-realloc-failure
--- tgc.c
+++ tgc.c
@@ -357,6 +357,11 @@
|  tgc_ptr_t *p;
|  void *qtr = realloc(ptr, size);
|
+  if (qtr == NULL) {
+    tgc_rem(gc, ptr);
+    return qtr;
+  }
+
|  p = tgc_get_ptr(gc, ptr);
|
|  if (p && qtr == ptr) {

~~~ 147. realloc-handle-null
--- tgc.c
+++ tgc.c
@@ -362,6 +362,11 @@
|    return qtr;
|  }
|
+  if (ptr == NULL) {
+    tgc_add(gc, qtr, size, 0, NULL);
+    return qtr;
+  }
+
|  p = tgc_get_ptr(gc, ptr);
|
|  if (p && qtr == ptr) {

~~~ 148. free-prototype
--- tgc.h
+++ tgc.h
@@ -37,6 +37,7 @@
|void *tgc_alloc(tgc_t *gc, size_t size);
|void *tgc_calloc(tgc_t *gc, size_t num, size_t size);
|void *tgc_realloc(tgc_t *gc, void *ptr, size_t size);
+void tgc_free(tgc_t *gc, void *ptr);
|
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*));
|void *tgc_calloc_opt(tgc_t *gc, size_t num, size_t size, int flags,

~~~ 149. free
--- tgc.c
+++ tgc.c
@@ -385,6 +385,17 @@
|  return NULL;
|}
|
+void tgc_free(tgc_t *gc, void *ptr) {
+  tgc_ptr_t *p = tgc_get_ptr(gc, ptr);
+  if (p) {
+    if (p->dtor) {
+      p->dtor(ptr);
+    }
+    free(ptr);
+    tgc_rem(gc, ptr);
+  }
+}
+
|void *tgc_alloc_opt(tgc_t *gc, size_t size, int flags, void(*dtor)(void*)) {
|  void *ptr = malloc(size);
|  if (ptr != NULL) {

~~~ 150. rem-ptr-frees-null
--- tgc.c
+++ tgc.c
@@ -59,6 +59,10 @@
|
|  if (gc->nitems == 0) { return; }
|
+  for (i = 0; i < gc->nfrees; i++) {
+    if (gc->frees[i].ptr == ptr) { gc->frees[i].ptr = NULL; }
+  }
+
|  i = tgc_hash(ptr) % gc->nslots; j = 0;
|
|  while (1) {

~~~ 151. sweep-check-frees-for-null
--- tgc.c
+++ tgc.c
@@ -273,8 +273,10 @@
|  gc->mitems = gc->nitems + (size_t)(gc->nitems * gc->sweepfactor) + 1;
|
|  for (i = 0; i < gc->nfrees; i++) {
-    if (gc->frees[i].dtor) { gc->frees[i].dtor(gc->frees[i].ptr); }
-    free(gc->frees[i].ptr);
+    if (gc->frees[i].ptr) {
+      if (gc->frees[i].dtor) { gc->frees[i].dtor(gc->frees[i].ptr); }
+      free(gc->frees[i].ptr);
+    }
|  }
|
|  free(gc->frees);

